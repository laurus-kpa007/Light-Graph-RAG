# 데이터 플로우 설계

## 목차
1. [전체 데이터 흐름](#1-전체-데이터-흐름)
2. [인덱싱 파이프라인](#2-인덱싱-파이프라인)
3. [검색 파이프라인](#3-검색-파이프라인)
4. [데이터 변환 프로세스](#4-데이터-변환-프로세스)
5. [저장소 구조](#5-저장소-구조)

---

## 1. 전체 데이터 흐름

### 1.1 시스템 레벨 데이터 흐름

```mermaid
graph TB
    subgraph "입력 데이터"
        A1[.docx 파일]
        A2[사용자 질문]
    end

    subgraph "전처리 계층"
        B1[DocxConverter]
        B2[MarkdownParser]
        B3[Chunker]
    end

    subgraph "처리 계층"
        C1[LightRAG Engine]
        C2[Ollama LLM]
        C3[Ollama Embedding]
    end

    subgraph "저장 계층"
        D1[(Knowledge Graph)]
        D2[(Vector Store)]
        D3[(Metadata DB)]
    end

    subgraph "검색 계층"
        E1[Graph Search]
        E2[Vector Search]
        E3[Result Fusion]
    end

    subgraph "출력"
        F1[답변 텍스트]
        F2[참조 문서]
    end

    A1 --> B1
    B1 --> B2
    B2 --> B3

    B3 --> C1
    C1 --> C2
    C1 --> C3

    C2 --> D1
    C3 --> D2
    C1 --> D3

    A2 --> E1
    A2 --> E2

    D1 --> E1
    D2 --> E2

    E1 --> E3
    E2 --> E3

    E3 --> C2
    C2 --> F1
    E3 --> F2

    style C1 fill:#ff9999
    style E3 fill:#99ccff
```

### 1.2 데이터 변환 단계

```mermaid
stateDiagram-v2
    [*] --> RawDocument: .docx 파일
    RawDocument --> Markdown: MarkItDown 변환
    Markdown --> StructuredDoc: 파싱 및 구조화
    StructuredDoc --> Chunks: 청크 분할

    Chunks --> Entities: 엔티티 추출
    Chunks --> Embeddings: 임베딩 생성

    Entities --> GraphNodes: 노드 생성
    Entities --> GraphEdges: 엣지 생성

    GraphNodes --> KnowledgeGraph: 저장
    GraphEdges --> KnowledgeGraph: 저장
    Embeddings --> VectorDB: 저장

    KnowledgeGraph --> SearchResults: 검색
    VectorDB --> SearchResults: 검색

    SearchResults --> Answer: 답변 생성
    Answer --> [*]

    note right of Entities
        Gemma3 LLM 사용
        한국어 프롬프트 적용
    end note

    note right of Embeddings
        BGE-M3 모델 사용
        768차원 벡터
    end note
```

---

## 2. 인덱싱 파이프라인

### 2.1 상세 인덱싱 흐름

```mermaid
sequenceDiagram
    autonumber
    participant User
    participant UI
    participant Preprocessor
    participant Chunker
    participant Indexer
    participant LightRAG
    participant Ollama
    participant Storage

    User->>UI: .docx 파일 업로드
    UI->>Preprocessor: 전처리 요청

    rect rgb(255, 240, 240)
        Note over Preprocessor: 전처리 단계
        Preprocessor->>Preprocessor: MarkItDown 변환
        Preprocessor->>Preprocessor: 마크다운 파싱
        Preprocessor->>Chunker: 파싱된 문서 전달
        Chunker->>Chunker: 청크 분할
        Chunker-->>Preprocessor: 청크 리스트
    end

    Preprocessor->>Indexer: 청크 리스트 전달

    loop 청크 배치별
        rect rgb(240, 255, 240)
            Note over Indexer,Ollama: 인덱싱 단계
            Indexer->>LightRAG: insert(chunk_text)

            par 병렬 처리
                LightRAG->>Ollama: 엔티티 추출 요청 (Gemma3)
                Note over Ollama: 한국어 최적화 프롬프트 사용
                Ollama-->>LightRAG: 엔티티 목록

                LightRAG->>Ollama: 관계 추출 요청 (Gemma3)
                Ollama-->>LightRAG: 관계 목록
            end

            LightRAG->>Ollama: 임베딩 생성 (BGE-M3)
            Ollama-->>LightRAG: 임베딩 벡터

            LightRAG->>Storage: 그래프 노드/엣지 저장
            LightRAG->>Storage: 벡터 인덱스 저장
            LightRAG->>Storage: 메타데이터 저장
        end

        Indexer->>UI: 진행률 업데이트
    end

    Indexer-->>User: 인덱싱 완료
```

### 2.2 청크별 데이터 처리

```mermaid
flowchart TD
    A[청크 입력] --> B{청크 유효성 검증}
    B -->|유효| C[전처리]
    B -->|무효| Z[스킵]

    C --> D[텍스트 정규화]
    D --> E[메타데이터 추출]

    E --> F[엔티티 추출 요청]
    F --> G{엔티티 발견?}

    G -->|Yes| H[엔티티 정규화]
    G -->|No| I[기본 엔티티 생성]

    H --> J[관계 추출 요청]
    I --> J

    J --> K{관계 발견?}
    K -->|Yes| L[관계 검증]
    K -->|No| M[청크만 저장]

    L --> N[그래프 노드 생성]
    M --> O[임베딩 생성 요청]

    N --> P[그래프 엣지 생성]
    P --> O

    O --> Q[벡터 정규화]
    Q --> R[저장소에 기록]

    R --> S[인덱스 업데이트]
    S --> T[완료]

    style F fill:#ffe6e6
    style J fill:#ffe6e6
    style O fill:#e6f3ff
```

### 2.3 엔티티 추출 상세 프로세스

```mermaid
sequenceDiagram
    participant Chunk
    participant LightRAG
    participant Prompt
    participant Gemma3
    participant Parser

    Chunk->>LightRAG: 청크 텍스트
    LightRAG->>Prompt: 한국어 엔티티 추출 프롬프트 로드
    Prompt-->>LightRAG: 프롬프트 템플릿

    LightRAG->>LightRAG: 프롬프트에 청크 삽입

    LightRAG->>Gemma3: 엔티티 추출 요청
    Note over Gemma3: JSON 형식으로 응답

    Gemma3-->>LightRAG: Raw JSON 응답

    LightRAG->>Parser: JSON 파싱
    Parser->>Parser: 엔티티 검증

    alt 엔티티 유효
        Parser-->>LightRAG: 엔티티 리스트
    else 엔티티 무효
        Parser-->>LightRAG: 빈 리스트
        Note over LightRAG: 재시도 또는 스킵
    end

    LightRAG->>LightRAG: 엔티티 정규화
    Note over LightRAG: - 중복 제거<br/>- 타입 검증<br/>- 한글 인코딩 확인
```

---

## 3. 검색 파이프라인

### 3.1 하이브리드 검색 상세 흐름

```mermaid
sequenceDiagram
    autonumber
    participant User
    participant UI
    participant Searcher
    participant GraphDB
    participant VectorDB
    participant Ollama
    participant Ranker
    participant Generator

    User->>UI: 질문 입력
    UI->>Searcher: search(query, mode="hybrid")

    rect rgb(255, 250, 240)
        Note over Searcher,Ollama: 질문 전처리
        Searcher->>Searcher: 질문 정규화
        Searcher->>Ollama: 질문 임베딩 생성 (BGE-M3)
        Ollama-->>Searcher: 질문 벡터
    end

    par 병렬 검색
        rect rgb(240, 255, 250)
            Note over Searcher,GraphDB: 그래프 검색
            Searcher->>GraphDB: 엔티티 매칭 쿼리
            GraphDB-->>Searcher: 관련 엔티티

            Searcher->>GraphDB: 관계 확장 쿼리
            GraphDB-->>Searcher: 연결된 엔티티/청크
        end

        rect rgb(240, 245, 255)
            Note over Searcher,VectorDB: 벡터 검색
            Searcher->>VectorDB: 코사인 유사도 검색
            VectorDB-->>Searcher: Top-K 유사 청크
        end
    end

    Searcher->>Ranker: 검색 결과 융합
    Note over Ranker: RRF 알고리즘 적용

    Ranker->>Ranker: 중복 제거
    Ranker->>Ranker: 재순위화
    Ranker-->>Searcher: 최종 컨텍스트 청크

    Searcher->>Generator: 컨텍스트 + 질문
    Generator->>Ollama: 답변 생성 요청 (Gemma3)
    Note over Ollama: 한국어 답변 생성 프롬프트

    Ollama-->>Generator: 생성된 답변

    Generator-->>Searcher: SearchResult
    Searcher-->>UI: 답변 + 참조 문서
    UI-->>User: 결과 표시
```

### 3.2 검색 모드별 차이

```mermaid
graph TB
    A[사용자 질문] --> B{검색 모드}

    B -->|naive| C[단순 벡터 검색]
    B -->|local| D[지역 그래프 검색]
    B -->|global| E[전역 그래프 검색]
    B -->|hybrid| F[하이브리드 검색]

    C --> C1[질문 임베딩]
    C1 --> C2[벡터 DB 검색]
    C2 --> G[답변 생성]

    D --> D1[엔티티 추출]
    D1 --> D2[1-hop 이웃 탐색]
    D2 --> D3[관련 청크 수집]
    D3 --> G

    E --> E1[전역 엔티티 분석]
    E1 --> E2[커뮤니티 검출]
    E2 --> E3[중요 청크 선정]
    E3 --> G

    F --> F1[벡터 검색]
    F --> F2[그래프 검색]
    F1 --> F3[RRF 융합]
    F2 --> F3
    F3 --> G

    G --> H[최종 답변]

    style F fill:#ffcccc
    style F3 fill:#ccffcc
```

### 3.3 RRF 융합 알고리즘 상세

```mermaid
flowchart TD
    A[그래프 검색 결과] --> C[결과 병합]
    B[벡터 검색 결과] --> C

    C --> D[청크 ID별 그룹화]

    D --> E{각 청크 ID}

    E --> F[그래프 검색 순위 확인]
    E --> G[벡터 검색 순위 확인]

    F --> H["RRF 점수 계산<br/>1/(k + graph_rank)"]
    G --> I["RRF 점수 계산<br/>1/(k + vector_rank)"]

    H --> J[점수 합산]
    I --> J

    J --> K{모든 청크 처리?}

    K -->|No| E
    K -->|Yes| L[점수 기준 정렬]

    L --> M[Top-K 선택]
    M --> N[중복 청크 제거]
    N --> O[관련성 점수 필터링]

    O --> P[최종 컨텍스트]

    style J fill:#ffe6e6
    style M fill:#e6ffe6
```

**RRF 점수 계산 예시**:
```
k = 60 (상수)

청크 A:
- 그래프 검색 순위: 3위
- 벡터 검색 순위: 5위
- RRF 점수 = 1/(60+3) + 1/(60+5) = 0.0159 + 0.0154 = 0.0313

청크 B:
- 그래프 검색 순위: 1위
- 벡터 검색 순위: 10위
- RRF 점수 = 1/(60+1) + 1/(60+10) = 0.0164 + 0.0143 = 0.0307

청크 C:
- 그래프 검색 순위: 없음
- 벡터 검색 순위: 2위
- RRF 점수 = 0 + 1/(60+2) = 0.0161

정렬 결과: B(0.0313) > A(0.0307) > C(0.0161)
```

---

## 4. 데이터 변환 프로세스

### 4.1 .docx → Markdown 변환

```mermaid
flowchart LR
    A[.docx 파일] --> B[MarkItDown]

    B --> C{요소 타입}

    C -->|텍스트| D[일반 텍스트<br/>마크다운 변환]
    C -->|제목| E["헤더 변환<br/># ## ###"]
    C -->|표| F[Markdown Table<br/>구조 유지]
    C -->|이미지| G[이미지 링크<br/>변환]
    C -->|목록| H[리스트 변환<br/>- 1."]

    D --> I[Markdown 텍스트]
    E --> I
    F --> I
    G --> I
    H --> I

    I --> J[후처리]
    J --> K[최종 Markdown]

    style F fill:#ffe6e6
    Note: "표 구조 유지 필수"
```

**변환 예시**:
```markdown
입력 (.docx):
┌─────────────────────────────┐
│ 제1장 총칙                  │
│                             │
│ 제1조 (목적)                │
│ 이 규정은 회사의...         │
│                             │
│ ┌────┬────┬────┐            │
│ │구분│일수│비고│            │
│ ├────┼────┼────┤            │
│ │연차│15일│    │            │
│ └────┴────┴────┘            │
└─────────────────────────────┘

출력 (Markdown):
# 제1장 총칙

## 제1조 (목적)

이 규정은 회사의...

| 구분 | 일수 | 비고 |
|------|------|------|
| 연차 | 15일 |      |
```

### 4.2 Markdown → 구조화된 문서

```mermaid
stateDiagram-v2
    [*] --> ParseLines: Markdown 텍스트
    ParseLines --> DetectHeader: 라인별 분석

    DetectHeader --> HeaderLevel: # 개수 확인
    HeaderLevel --> CreateSection: 섹션 생성

    DetectHeader --> DetectTable: | 기호 확인
    DetectTable --> ParseTable: 표 파싱

    DetectHeader --> NormalText: 일반 텍스트
    NormalText --> AppendContent: 섹션에 추가

    CreateSection --> BuildHierarchy: 계층 구조 구축
    ParseTable --> BuildHierarchy
    AppendContent --> BuildHierarchy

    BuildHierarchy --> StructuredDoc: 구조화 완료
    StructuredDoc --> [*]

    note right of ParseTable
        표는 분할하지 않음
        하나의 단위로 유지
    end note
```

### 4.3 구조화된 문서 → 청크

```mermaid
flowchart TD
    A[StructuredDocument] --> B[섹션 순회]

    B --> C{섹션 크기}

    C -->|"< min_size"| D{이전 청크 존재?}
    D -->|Yes| E[이전 청크와 병합]
    D -->|No| F[단독 청크 생성]

    C -->|"min ~ max"| G{표 포함?}
    G -->|Yes| H[표 분리 여부 판단]
    G -->|No| I[단일 청크 생성]

    H -->|분리 불가| I
    H -->|분리 가능| J[표 별도 청크]

    C -->|"> max_size"| K[다중 청크 분할]

    K --> L[문장 경계 탐지]
    L --> M[오버랩 적용]
    M --> N[청크 리스트 생성]

    E --> O[메타데이터 추가]
    F --> O
    I --> O
    J --> O
    N --> O

    O --> P[Chunk 객체 생성]

    P --> Q{다음 섹션?}
    Q -->|Yes| B
    Q -->|No| R[완료]

    style G fill:#fff4e6
    style H fill:#ffe6e6
```

**청크 분할 예시**:
```
섹션: "제2조 연차 사용 규정" (1200자)

오버랩 전략:
┌──────────────────────┐
│ 청크 1 (1000자)      │
│                      │
│   ┌─────┐ (50자)    │
│   │오버랩│            │
└───┴─────┴────────────┘
        ┌──────────────┐
        │ 청크 2 (250자)│
        └──────────────┘

청크 1: "제2조 연차 사용 규정. 직원은 1년..." (1000자)
청크 2: "...연차를 사용할 수 있다. 단, 부서장의 승인..." (250자)

오버랩 부분: "...연차를 사용할 수 있다." (50자)
```

---

## 5. 저장소 구조

### 5.1 LightRAG 저장소 구조

```mermaid
graph TB
    subgraph "Working Directory"
        A[index/]
    end

    subgraph "Graph Storage"
        B[graph_chunk_entity_relation.graphml]
        C[graph_entities.json]
        D[graph_relationships.json]
    end

    subgraph "Vector Storage"
        E[vector_chunks.json]
        F[vector_embeddings.npy]
        G[vector_index.faiss]
    end

    subgraph "Metadata Storage"
        H[chunks.json]
        I[documents.json]
        J[config.json]
    end

    A --> B
    A --> C
    A --> D
    A --> E
    A --> F
    A --> G
    A --> H
    A --> I
    A --> J

    style B fill:#ffe6e6
    style E fill:#e6f3ff
```

### 5.2 지식 그래프 구조

```mermaid
graph LR
    subgraph "엔티티 노드"
        E1[("조직<br/>인사팀")]
        E2[("개념<br/>연차 규정")]
        E3[("기간<br/>15일")]
        E4[("절차<br/>휴가 신청")]
    end

    subgraph "청크 노드"
        C1["청크1<br/>제1조 목적"]
        C2["청크2<br/>제2조 연차"]
        C3["청크3<br/>제3조 절차"]
    end

    E1 -->|관리| E2
    E2 -->|기준| E3
    E2 -->|포함| E4

    C1 -.->|언급| E1
    C2 -.->|언급| E2
    C2 -.->|언급| E3
    C3 -.->|언급| E4

    style E1 fill:#ffcccc
    style E2 fill:#ccffcc
    style E3 fill:#ccccff
    style E4 fill:#ffffcc
    style C1 fill:#f0f0f0
    style C2 fill:#f0f0f0
    style C3 fill:#f0f0f0
```

### 5.3 벡터 저장소 구조

```mermaid
flowchart TB
    A[청크 텍스트] --> B[BGE-M3 임베딩]
    B --> C[768차원 벡터]

    C --> D[(벡터 인덱스)]

    subgraph "인덱스 구조"
        D --> E[FAISS Index]
        E --> F[청크 ID 매핑]
        F --> G[메타데이터 참조]
    end

    H[질문 벡터] --> I[코사인 유사도 계산]
    I --> D

    D --> J[Top-K 결과]
    J --> K[청크 검색]

    style C fill:#e6f3ff
    style E fill:#ffe6e6
```

**벡터 차원 구조**:
```
청크 벡터:
[0.023, -0.145, 0.892, ..., 0.456]
 ↑                            ↑
 차원 0                    차원 767
 (총 768차원)

유사도 계산:
cosine_similarity(query_vec, chunk_vec) = dot(q, c) / (||q|| * ||c||)

범위: -1 ~ 1
  1: 완전 유사
  0: 무관
 -1: 완전 반대
```

### 5.4 메타데이터 구조

```mermaid
erDiagram
    DOCUMENTS ||--o{ CHUNKS : contains
    CHUNKS ||--o{ ENTITIES : mentions
    ENTITIES ||--o{ RELATIONSHIPS : participates

    DOCUMENTS {
        string id PK
        string filename
        string original_path
        datetime indexed_at
        int chunk_count
        json metadata
    }

    CHUNKS {
        string id PK
        string document_id FK
        string content
        string section_path
        int chunk_index
        vector embedding
        json metadata
    }

    ENTITIES {
        string id PK
        string name
        string type
        string description
        int mention_count
    }

    RELATIONSHIPS {
        string id PK
        string source_entity FK
        string relation_type
        string target_entity FK
        string context
    }
```

---

## 6. 성능 최적화 전략

### 6.1 인덱싱 최적화

```mermaid
flowchart TD
    A[청크 리스트] --> B{배치 크기 설정}
    B --> C[배치별 병렬 처리]

    C --> D{GPU 사용 가능?}
    D -->|Yes| E[GPU 배치 추론]
    D -->|No| F[CPU 순차 처리]

    E --> G[배치 임베딩 생성]
    F --> G

    G --> H[비동기 저장]
    H --> I[인덱스 업데이트]

    I --> J{다음 배치?}
    J -->|Yes| C
    J -->|No| K[완료]

    style E fill:#ccffcc
    style H fill:#ffffcc
```

### 6.2 검색 최적화

```mermaid
flowchart LR
    A[질문] --> B[캐시 확인]
    B -->|Hit| C[캐시된 결과 반환]
    B -->|Miss| D[검색 실행]

    D --> E[병렬 검색]
    E --> F[결과 융합]
    F --> G[캐시 저장]
    G --> H[결과 반환]

    style C fill:#ccffcc
    style G fill:#ffffcc
```

---

## 7. 에러 처리 및 복구

### 7.1 에러 처리 흐름

```mermaid
stateDiagram-v2
    [*] --> Processing
    Processing --> Success: 정상 처리
    Processing --> Error: 에러 발생

    Error --> Retry: 재시도 가능
    Error --> Skip: 치명적 에러

    Retry --> Processing: 재시도
    Retry --> Failed: 최대 재시도 초과

    Skip --> Logged: 에러 로깅
    Failed --> Logged

    Success --> [*]
    Logged --> [*]: 다음 작업 진행

    note right of Retry
        - 네트워크 에러
        - Timeout
        - LLM 응답 에러
    end note

    note right of Skip
        - 파일 손상
        - 인코딩 에러
        - 파싱 실패
    end note
```

---

**작성일**: 2026-01-17
**버전**: 1.0
